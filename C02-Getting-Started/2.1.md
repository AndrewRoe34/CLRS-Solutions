### Exercises 2.1-1
***
Using Figure 2.2 as a model, illustrate the operation of INSERTION-SORT on the array A = {31, 41, 59, 26, 41, 58}.

### `Answer`
![Box Visual](https://github.com/AndrewRoe34/CLRS-Solutions/blob/main/C02-Getting-Started/img/insertsort-box.png)

### Exercises 2.1-2
***
Rewrite the INSERTION-SORT procedure to sort into nonincreasing instead of nondecreasing order.

### `Answer`
![Pseudocode](https://github.com/AndrewRoe34/CLRS-Solutions/blob/main/C02-Getting-Started/img/insertsort-perf.png)

### Exercises 2.1-3
***
Consider the **searching problem**:
<insert image>
Write pseudocode for **linear search**, which scans through the sequence, looking for *v*. Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.

### `Answer`
![Pseudocode](https://github.com/AndrewRoe34/CLRS-Solutions/blob/main/C02-Getting-Started/img/linear-search.png)

**Algorithm Proof**:

*Initialization*:
  
At the beginning before iteration, the subArray of all processed entries up to, but not including, the first index is *A[0]*. No elements have been skipped in the linear search.

*Maintenance*:

Each iteration, an additional element is added to the subArray of all processed entries that were not the desired element. No elements have been skipped as wwe iterate toward array completions *A[1...n]*.
  
*Termination*:

If we arrive at the desired value while within the array bounds *{1...n}*, we return the index of the desired value. However, after the *nth* iteration, i has surpassed the array's limits and thus we return NIL.

***
**Sample Code:**

```
#include <stdio.h>
#include <stdlib.h>

/**
 * @param A integer A
 * @param v value being searched
 * @param n length of array A
 */
int linearSearch(int *A, int v, int n)
{
    for(int i = 0; i < n; i++) {
        if(A[i] == v)
            return i;
    }
    return -1;
}

/**
 * Starting point of application
 */
int main()
{
    int A[] = {1, 2, 3, 4, 5};
    printf("Expected:  4, Actual:  %d\n", linearSearch(A, 5, sizeof(A) / sizeof(int)));
    printf("Expected: -1, Actual: %d\n", linearSearch(A, 13, sizeof(A) / sizeof(int)));
    return 0;
}
```
  
### Exercises 2.1-4
***
Consider the problem of adding two *n*-bit binary integers, stored in two *n*-elemnt arrays *A* and *B*. The sum of the two integers should be stored in binary form in an (*n* + 1)-element array *C*. State the problem formally and write pseudocode for adding the two integers.

### `Answer`
![Psuedocode](https://github.com/AndrewRoe34/CLRS-Solutions/blob/main/C02-Getting-Started/img/addbits-psuedo.png)

**Algorithm Proof**:

*Initialization*:
  
At the beginning, we initialize an array *C* to hold the maximum length of array *A* but with one additional slot (this accounts for the possible overflow from addition). We also initialize our remainder variable *r* to 0. The subArray *C*, which contains the sum of *{A[i] + B[i] + r}* for each index from from *A*'s maximum index to its first. Because have yet to begin the iteration, our array *C* is empty.

*Maintenance*:

Each iteration, we take the sum of the three elements. The maximum value can be 3 while the minimum is 0. To categorize, any total that is greater than or equal to 2 will result in *r* getting assigned 1. However, if the value is even, we assign the current index 0 (This makes sense if our value is 0 or 2, the first is empty and the second only has a remainder. For 1 and 3, the first has no remainder but the second does. Both of which assign a value of 1). This process continues upon each iteration.
  
*Termination*:

Upon completion of the iteration process, we assign array *C*'s first index the value of the last remainder (0 or 1). This concludes the AddBits(A,B) algorithm.
  
***
**Sample Code:**
  
```
#include <stdio.h>
#include <stdlib.h>

/**
 * Adds the two binary values together
 *
 * @param A char array A
 * @param B char array B
 * @param n length of A (same as B)
 * @return pointer to char array C (has length n + 1)
 */
char *addBits(char *A, char *B, int n)
{
    char r = 0;
    char *C = (char *) malloc(sizeof(char) * (n + 1));
    for(; (n - 1) >= 0; n--) {
        char s = A[n - 1] + B[n - 1] + r;
        C[n] = s % 2;
        r = s > 1 ? 1 : 0;
    }
    C[0] = r;
    return C;
}

/**
 * Starting point of application
 */
int main()
{
    char A[] = {1, 0, 1, 1};
    char B[] = {1, 1, 0, 1};
    char *C = addBits(A, B, sizeof(A) / sizeof(char)); //should be 11000
    for(int i = 0; i < 5; i++)
        printf("%d", C[i]);

    return 0;
}
```


***
Follow [@AndrewRoe34](https://github.com/AndrewRoe34) on GitHub if interested in contributing
